\usepackage{ucll-code}
\usetikzlibrary{shadows,shapes.multipart}

\title{References}
\author{Fr\'ed\'eric Vogels}

\newcommand{\highlightbox}[2][]{
  \draw[opacity=.75,ultra thick,red,#1] ($ (#2.south west) + (-.1,-.1) $) rectangle ($ (#2.north east) + (.1,.1) $)
}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Pointers}
  \begin{procontralist}
    \pro Efficient way to give access to large amounts of data
    \pro Allow to give write-access to own variables
    \con Clumsy syntax
  \end{procontralist}
  \vskip5mm
  \begin{overprint}
    \onslide<1>
    \code[language=c++14]{clumsy1.cpp}

    \onslide<2>
    \code[language=c++14]{clumsy2.cpp}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{References}
  \begin{itemize}
    \item C has only pointers
    \item \cpp\ introduced references
    \item Gives same ``power'' as pointers
    \item Uses pointers behind the scenes
    \item Much cleaner syntax
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Syntax}
  \begin{center}
    \begin{tabular}{cl}
      \textbf{Syntax}       & \textbf{Semantic} \\
      \toprule
      \texttt{T[]}          & Array of \texttt{T}s \\
      \texttt{const T}      & Readonly view of \texttt{T} \\
      \texttt{T*}           & Pointer to \texttt{T} \\
      \alert{\texttt{T\&}}  & \alert{Reference to \texttt{T}} \\
    \end{tabular}
  \end{center}
  \begin{framed}
    \begin{center} \Large
      \textbf{Warning} \\[2mm]
      Do not confuse with address-of operator!
    \end{center}
  \end{framed}
\end{frame}

\begin{frame}
  \frametitle{Semantics}
  \code[width=.5\linewidth,language=c++14]{by-value.cpp}
  \begin{itemize}
    \item {\tt foo} receives \emph{copy} of {\tt x}
    \item {\tt foo} only has access to the {\tt value} of the variable
    \item {\tt foo} cannot modify {\tt x} in any way
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Semantics}
  \code[width=.5\linewidth,language=c++14]{by-pointer.cpp}
  \begin{itemize}
    \item \texttt{foo} receives the \emph{address} of \texttt{x}
    \item \texttt{foo} has access to the {\tt value} of \texttt{x}
          \begin{itemize}
            \item Syntax: \texttt{int y = *arg}
          \end{itemize}
    \item \texttt{foo} can modify {\tt x}
          \begin{itemize}
            \item Syntax: \texttt{*arg = 6}
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Semantics}
  \code[width=.5\linewidth,language=c++14]{by-reference.cpp}
  \begin{itemize}
    \item {\tt foo} receives a \emph{reference} to {\tt x}
    \item Gives same access as when using pointer
          \begin{itemize}
            \item \texttt{foo} can read \texttt{x}
            \item \texttt{foo} can modify \texttt{x}
          \end{itemize}
    \item What's the difference then except for the \texttt{\&}?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Syntax}
  \code[language=c++14,width=.5\linewidth,font=\small]{reference-syntax.cpp}
  \begin{itemize}
    \item No need for dereferencing (no \texttt{*x}, just \texttt{x})
    \item Cleaner syntax
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Aliasing}
  \begin{itemize}
    \item Introducing another name for a variable
  \end{itemize}
  \vskip5mm
  \begin{overprint}
    \onslide<1>
    \code[language=c++14,font=\small]{aliasing1.cpp}

    \onslide<2>
    \code[language=c++14,font=\small]{aliasing2.cpp}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{Returning References}
  \code[language=c++14]{max-reference.cpp}
  \begin{itemize}
    \item Intuition: \texttt{max} returns the variable itself, not just its value
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Returning References}
  \code[language=c++14]{field-reference.cpp}
\end{frame}

\begin{frame}
  \frametitle{Limitations of References}
  \begin{itemize}
    \item References do not fully replace pointers
          \begin{itemize}
            \item References cannot be retargeted
            \item References cannot be null
          \end{itemize}
  \end{itemize}
  \vskip4mm
  \code[language=c++14]{redirection.cpp}
\end{frame}

\begin{frame}
  \frametitle{When To Use References}
  \begin{itemize}
    \item Mostly used with functions
          \begin{itemize}
            \item \texttt{const T\&} parameters
            \item \texttt{T\&} return values
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When Not To Use References}
  \code[language=c++14]{out-params.cpp}
  \begin{itemize}
    \item It is important to know whether \texttt{x} could change
    \item If signature is \texttt{void foo(int)}, \texttt{x} cannot change
    \item If signature is \texttt{void foo(int\&)}, \texttt{x} could change
    \item Whether \texttt{x} can change depends on \texttt{foo}'s signature
    \item Signature not immediately visible above
    \item We would have to look it up
    \item Would seriously impede code reading
    \item Ideally, it should be clear from above code alone whether \texttt{x} can change
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When Not To Use References}
  \begin{itemize}
    \item We introduce convention
    \item If we write \texttt{foo(x)}, \texttt{x} should remain unmodified
    \item If we write \texttt{foo(\&x)}, it signals \texttt{x} could change
    \item The \& makes it explicit that \texttt{x} could change
    \item No need to look up \texttt{foo}'s signature
    \item This way, we are able to understand code quicker
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{How To Pass Parameters}
  \begin{center}
    \begin{tabular}{ccc}
      & \textbf{Small} & \textbf{Large} \\
      \toprule
      \textbf{Read} & \texttt{T} & \texttt{const T\&} \\
      \textbf{Read+Write} & \texttt{T*} & \texttt{T*} \\
    \end{tabular}
  \end{center}
  \vskip4mm
  \structure{Readonly Access}
  \begin{itemize}
    \item Small values: pass by value
    \item Large values: pass by const reference
  \end{itemize}
  \vskip4mm
  \structure{Read and Write Access}
  \begin{itemize}
    \item Always by pointer
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Summary}
  \structure{Types}
  \begin{center}
    \begin{tabular}{cc}
      \textbf{Syntax} & \textbf{Semantics} \\
      \toprule
      \texttt{T} & Plain old \texttt{T} \\
      \texttt{T*} & Pointer to \texttt{T} \\
      \texttt{T\&} & Reference to \texttt{T} \\
    \end{tabular}
  \end{center}
  \vskip4mm
  \structure{Operators}
  \begin{center}
    \begin{tabular}{cc}
      \textbf{Syntax} & \textbf{Semantics} \\
      \toprule
      \texttt{x} & Value of \texttt{x} \\
      \texttt{\&x} & Address of \texttt{x} \\
      \texttt{*x} & Dereference \texttt{x}
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Summary}
  \code[language=c++14]{calling-syntax.cpp}
\end{frame}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "references"
%%% End:
