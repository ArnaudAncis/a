\documentclass{../ucll-slides}
\usepackage{../pvm}
\usetikzlibrary{shadows,shapes.multipart}

\title{References}
\author{Fr\'ed\'eric Vogels}

\newcommand{\highlightbox}[2][]{
  \draw[opacity=.75,ultra thick,red,#1] ($ (#2.south west) + (-.1,-.1) $) rectangle ($ (#2.north east) + (.1,.1) $)
}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Pointers}
  \begin{procontralist}
    \pro Efficient way to give access to large amounts of data
    \pro Allow to give write-access to own variables
    \con Clumsy syntax
  \end{procontralist}
  \vskip5mm
  \structure{Example (peek into future)}
  \code[width=.95\linewidth,font size=\footnotesize,frame=lines]{operator-overloading-bad.cpp}
\end{frame}

\begin{frame}
  \frametitle{References}
  \begin{itemize}
    \item Not in C, new in \cpp
    \item Gives same ``power'' as pointers
    \item Uses pointers behind the scenes
    \item Much cleaner syntax
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Syntax}
  \begin{itemize}
    \item {\tt T}: some type
    \item {\tt T[]}: array of {\tt T}
    \item {\tt const T}: readonly view of {\tt T}
    \item {\tt T*}: pointer to {\tt T}
    \item<2-> {\tt T\& }: reference to {\tt T}
  \end{itemize}
  \visible<3->{
    \begin{framed}
      \begin{center} \Large
        \textbf{Warning} \\[2mm]
        Do not confuse with address-of operator!
      \end{center}
    \end{framed}
  }
\end{frame}

\begin{frame}
  \frametitle{Semantics}
  \code[frame=lines,width=.5\linewidth]{by-value.cpp}
  \begin{itemize}
    \item {\tt foo} receives \emph{copy} of {\tt x}
    \item {\tt foo} only has access to the {\tt value} of the variable
    \item {\tt foo} cannot modify {\tt x} in any way
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Semantics}
  \code[frame=lines,width=.5\linewidth]{by-pointer.cpp}
  \begin{itemize}
    \item {\tt foo} receives the \emph{address} of {\tt x}
    \item {\tt foo} has access to the {\tt value} of {\tt x} (e.g.\ {\tt int y = *arg})
    \item {\tt foo} can modify {\tt x} (e.g.\ {\tt *arg = 6})
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Semantics}
  \code[frame=lines,width=.5\linewidth]{by-reference.cpp}
  \begin{itemize}
    \item {\tt foo} receives a \emph{reference} to {\tt x}
    \item In essence, this is the same as receiving the address of {\tt x}
    \item {\tt foo} has access to the {\tt value} of {\tt x} (e.g.\ {\tt int y = arg})
    \item {\tt foo} can modify {\tt x} (e.g.\ {\tt arg = 6})
    \item Whenever {\tt foo} interacts with {\tt arg}, it is interacting with {\tt x}
    \item References offer pointer-functionality with cleaner syntax
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Quiz}
  \code[font size=\small,frame=lines,width=.9\linewidth]{alias.cpp}
\end{frame}

\begin{frame}
  \frametitle{Quiz}
  \code[font size=\small,frame=lines,width=.9\linewidth]{byref.cpp}
\end{frame}

\begin{frame}
  \frametitle{When To Use References}
  \begin{itemize}
    \item Power of pointers
    \item Without the ugliness
    \item Why not always use references instead of pointers?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Being Explicit About Intentions}
  \code[frame=lines,width=.5\linewidth]{explicit.cpp}
  \begin{itemize}
    \item What guarantees do we have?
    \item If {\tt foo} takes {\tt int}, we know {\tt x} will not change
    \item If {\tt foo} takes {\tt int\&}, {\tt x} will probably change
    \item We cannot infer which is true based on syntax of {\tt foo(x)}
    \item Working with pointers is more explicit
          \begin{itemize}
            \item {\tt foo(x)}: {\tt x} will not change
            \item {\tt foo(\&x)}: {\tt x} will probably change
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Rules of Thumb}
  \begin{itemize}
    \item Readonly access to small data: use {\tt T}
    \item Readonly access to large data: use {\tt const T\&}
    \item Read/write access: use {\tt T*}
  \end{itemize}  
\end{frame}

\begin{frame}
  \frametitle{Interesting Use Case}

\end{frame}

\end{document}