<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>PVM Assignment</title>
    <%= default_externals %>
    <script src="<%= Settings::SHARED_URL %>/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="<%= Settings::SHARED_URL %>/source-editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="<%= Settings::SHARED_URL %>/revealer.js" type="text/javascript" charset="utf-8"></script>
    
    <%= Html::Generation::Quiz.setup %>
    <style>
      #colours {
        margin-left: auto;
        margin-right: auto;
        width: 50%;
      }

      #colours td:first-child {
        color: #FFF;
        text-align: center;
      }

      #colours td {
        padding: 5px;
      }

      input {
        width: 100px;
      }

      input.correct {
        background: #AFA;
      }

      input.incorrect {
        background: #FAA
      }

      .solution {
        border: 1px solid black;
        padding: 10px;
        width: 25%;
        margin-left: auto;
        margin-right: auto;
        text-align: center;
      }

      .message {
        font-size: 2em;
        font-weight: bold;
        text-align: center;
        width: 75%;
        margin: 100px auto;
        padding: 20px;
        background: #F44;
        box-shadow: 0px 0px 50px 30px #F44;
      }

      .git {
        border: 1px solid black;
        padding: 10px;
        width: 80%;
        margin: 10px auto;
        text-align: center;
        font-weight: bold;
      }

      .cake {
        border: 1px solid black;
        padding: 10px;
        width: 80%;
        margin: 10px auto;
        font-weight: bold;
        background: #FFAA77;
      }

      .cake .header {
        display: block;
        text-align: center;
        font-size: 2em;
        font-weight: bold;
      }

      .revealer {
        border: 1px solid black;
        padding: 10px;
        width: 25%;
        margin: 10px auto;      
        text-align: center;
        cursor: help;
      }

      .explanation {
        border: 1px solid black;
        padding: 10px;
        width: 75%;
        margin: 10px auto;
      }
    </style>
  </head>

  <body>
    <header>
      <div class="center-vertically">Classes</div>
    </header>
    <div id="contents">
      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             struct Foo
             {
               int x;

               Foo(int x) : x(x) { }
             };

             Foo operator -(const Foo& foo)
             {
               return Foo(-foo.x);
             }

             int main()
             {
               Foo a(15), b(5);
               Foo c = a - b;

               std::cout << c.x;
             }
           END

           self.output = 'DNC'

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 The code above overloads the <em>unary</em> operator -, not the binary one. In other words,
                 given the operator overload above, you can write <code>-a</code> and <code>-b</code>, but not <code>a-b</code>.
               </p>
             </div>
           END
         end
      %>
      
      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             struct Foo
             {
               int x;

               Foo(int x) : x(x) { }
             };

             Foo operator -(const Foo& a, const Foo& b)
             {
               return Foo(a.x - b.x);
             }

             int main()
             {
               Foo a(15), b(5);
               Foo c = a - b;

               std::cout << c.x;
             }
           END

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 The code above overloads the <em>unary</em> operator -, not the binary one. In other words,
                 given the operator overload above, you can write <code>-a</code> and <code>-b</code>, but not <code>a-b</code>.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             struct Foo
             {
               int x;

               Foo(int x) : x(x) { }
             };

             int operator &(const Foo& a)
             {
               return a.x * 2;
             }

             int main()
             {
               Foo a(15);

               std::cout << &a;
             }
           END

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 This example is particularly vile: we overload the <code>&amp;</code> operator, which is generally expected to return the address of the variable.
                 However, it is possible to give it a different behaviour, which is what we do here: <code>&amp;a</code> has now
                 become a way of getting twice the value of <code>a.x</code>. We cannot write <code>&amp;a</code> to get <code>a</code>'s address anymore.
                 (It is still possible to get its address, but it requires some serious hoop-jumping.)
               </p>
               <p>
                 It is very important that you only use operator overloading when it fits expectations, i.e. use <code>+</code> for addition-like operations,
                 but don't start using it on <code>OilTank</code>s.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             class Foo {
               int c;

             public:
               Foo() : c(0) { }

               int operator ()() { return c++; }
             };

             int main()
             {
               Foo foo;

               std::cout << foo();
               std::cout << foo();
               std::cout << foo();
             }
           END

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             class Foo {
               int c;

             public:
               Foo() : c(0) { }

               int operator ()() { return c++; }
             };

             int main()
             {
               Foo foo;

               std::cout << foo() << foo() << foo();
             }
           END

           self.output = '???'

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 Within two "sequence points", the compiler has the freedom to reorder operations as it sees fit.
                 The rules about sequence points are a bit complicated (and even outdated since C++11, they've been
                 replaced by something probably even more confusing), but suffice it to say that it's a bad idea
                 to put multiple state modifying operations on the same line. Here, each <code>foo()</code>
                 operations modifies the value of some variable (hence it is state modifying),
                 and since they appear on the same line, you have no way of knowing in what order
                 it will be executed. For example, on this compiler, the program printed 210.
               </p>
               <p>
                 This is not operator overloading specific. For example, when calling a normal function <code>bar(x++, x++, x++)</code>
                 the actual result also remains a surprise.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             class Foo {
               int c;

             public:
               Foo() : c(0) { }

               int operator ()() { return c++; }
             };

             int main()
             {
               Foo foo;

               std::cout << foo() << foo() << foo();
             }
           END

           self.output = '???'

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 Within two "sequence points", the compiler has the freedom to reorder operations as it sees fit.
                 The rules about sequence points are a bit complicated (and even outdated since C++11, they've been
                 replaced by something probably even more confusing), but suffice it to say that it's a bad idea
                 to put multiple state modifying operations on the same line. Here, each <code>foo()</code>
                 operations modifies the value of some variable (hence it is state modifying),
                 and since they appear on the same line, you have no way of knowing in what order
                 it will be executed. For example, on this compiler, the program printed 210.
               </p>
               <p>
                 This is not operator overloading specific. For example, when calling a normal function <code>bar(x++, x++, x++)</code>
                 the actual result also remains a surprise.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             struct Foo {
               int x;

               Foo() : x(5) { }
             };

             std::ostream& operator <<(std::ostream& out, const Foo& foo)
             {
               return out << foo.x << foo.x+1 << foo.x+2;
             }

             int main()
             {
               Foo foo;
               
               std::cout << foo << foo << foo;
             }
           END

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 In case you expected undefined behaviour: no variable changes value anywhere. Whatever order <code>foo.x</code>, <code>foo.x+1</code>
                 and <code>foo.x+2</code> are evaluated in, the results are the same.
               </p>
               <p>
                 Each <code>out &lt;&lt; expr</code> is supposed to return <code>out</code> (hence the <code>std::ostream&amp;</code>
                 return value for <code>operator &lt;&lt;</code>). This makes it possible to chain multiple <code>&lt;&lt;</code> operations.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int operator <<(int x, int y)
             {
               int result = 1;

               while ( y-- ) result *= x;

               return result;
             }

             int main()
             {
               std::cout << (2 << 8);
             }
           END

           self.output = 'DNC'

           <<-END
             <p>What is the output of the following code? Enter <code>DNC</code> if the code does not compile. Enter <code>???</code> if its behaviour is undefined.</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               You are not allowed to redefine operators on primitive types. At least one of the operands must be a non-primitive type.
             </div>
           END
         end
      %>

      +=
      not necessarily consistent
      == !=

    </div>
  </body>

  <script>
    Quiz.formatQuizzes();
    SourceEditor.initialize();
    Revealer.initialize();
  </script>
</html>
