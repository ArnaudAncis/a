<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>PVM Assignment</title>
    <%= default_externals %>
    <script src="<%= Settings::SHARED_URL %>/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="<%= Settings::SHARED_URL %>/source-editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="<%= Settings::SHARED_URL %>/revealer.js" type="text/javascript" charset="utf-8"></script>
    
    <%= Html::Generation::Quiz.setup %>
    <style>
      #colours {
        margin-left: auto;
        margin-right: auto;
        width: 50%;
      }

      #colours td:first-child {
        color: #FFF;
        text-align: center;
      }

      #colours td {
        padding: 5px;
      }

      input {
        width: 100px;
      }

      input.correct {
        background: #AFA;
      }

      input.incorrect {
        background: #FAA
      }

      .solution {
        border: 1px solid black;
        padding: 10px;
        width: 25%;
        margin-left: auto;
        margin-right: auto;
        text-align: center;
      }

      .message {
        font-size: 2em;
        font-weight: bold;
        text-align: center;
        width: 75%;
        margin: 100px auto;
        padding: 20px;
        background: #F44;
        box-shadow: 0px 0px 50px 30px #F44;
      }

      .git {
        border: 1px solid black;
        padding: 10px;
        width: 80%;
        margin: 10px auto;
        text-align: center;
        font-weight: bold;
      }

      .cake {
        border: 1px solid black;
        padding: 10px;
        width: 80%;
        margin: 10px auto;
        font-weight: bold;
        background: #FFAA77;
      }

      .cake .header {
        display: block;
        text-align: center;
        font-size: 2em;
        font-weight: bold;
      }

      .revealer {
        border: 1px solid black;
        padding: 10px;
        width: 25%;
        margin: 10px auto;      
        text-align: center;
        cursor: help;
      }

      .explanation {
        border: 1px solid black;
        padding: 10px;
        width: 75%;
        margin: 10px auto;
      }
    </style>
  </head>

  <body>
    <header>
      <div class="center-vertically">References</div>
    </header>
    <div id="contents">
      <div class="message" title="You better be reading this!">
        If the given code does not compile, fill in DNC.
        If the given code has undefined behaviour, fill in UB.
      </div>

      <div class="message" title="You better be reading this!">
        Update the contents of the local copy of the PVM repo!
        Use <code>git pull</code> to fetch the new material.
      </div>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             void foo(int& x)
             {
                 x++;
             }

             int main()
             {
                 int x = 2;
                 foo(&x);

                 std::cout << x << std::endl;
             }
           END

           self.output = 'DNC'

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             void foo(int& x)
             {
                 x++;
             }

             int main()
             {
                 int x = 2;
                 foo(x);

                 std::cout << x << std::endl;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           extend RevealerMixin

           self.source = <<-END
             #include <iostream>

             int foo(int& x)
             {
                 return x + 1;
             }

             int main()
             {
                 std::cout << foo(5) << std::endl;
             }
           END

           self.output = 'DNC'

           explanation = <<-END
             <p>
               <code>foo</code> asks for a reference to an <code>int</code>,
               which means that there has to exist some <code>int</code>-variable
               somewhere in memory to refer to. If you pass along the constant
               <code>5</code>, no such variable exists.
             </p>
             <p>
               Imagine <code>foo</code> had <code>x++</code>
               as body and you pass it <code>5</code>. What would <code>5++</code> mean?
             </p>
             <p>
               If <code>foo</code> were to accept an <code>int</code>
               instead of an <code>int&amp;</code>, there would be no problem:
               a copy needs to be made, and this entails allocating
               new memory to host this copy (i.e. a new variable is created).
               <code>x++</code> would then operate on this newly allocated memory.
             </p>
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             #{show_explanation explanation}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int& foo(int& x)
             {
                 return x;
             }

             int main()
             {
                 int x = 2;
                 foo(x)++;

                 std::cout << x << std::endl;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           extend CakeMixin
           extend RevealerMixin

           cake_description = <<-END
             <p><code>return ++x;</code> works, but not <code>return x++;</code>. Why?</p>
           END

           self.source = <<-END
             #include <iostream>

             int& foo(int& x)
             {
                 return x + 1;
             }

             int main()
             {
                 int x = 2;
                 foo(x)++;

                 std::cout << x << std::endl;
             }
           END

           self.output = 'DNC'

           explanation = <<-END
             <p>
               <code>foo</code> should return a reference to an <code>int</code>.
               This means that there must exist an <code>int</code>-variable
               whose address can be found and passed around.
             </p>
             <p>
               Returning <code>x</code> works, as <code>x</code>
               is an existing variable, it has a memory location.
               Returning <code>x + 1</code>, however, will lead
               to an error. <code>x + 1</code> yields a value,
               but this value is not stored in memory,
               so no reference to it can be returned.
             </p>
             <p>
               If <code>foo</code> is supposed to increment its argument
               and return it by value, the following implementations will work:
             </p>
             <ul>
               <li><code>x++; return x;</code></li>
               <li><code>return x += 1;</code></li>
               <li><code>return ++x;</code></li>
             </ul>
             <p>
               These work because the increment value is stored in memory, i.e.
               in <code>x</code>.
             </p>
             #{cake cake_description}
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             #{show_explanation explanation}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           extend RevealerMixin
           
           self.source = <<-END
             #include <iostream>

             int& foo(int x)
             {
                 return x;
             }

             int main()
             {
                 int x = 2;
                 foo(x)++;

                 std::cout << x << std::endl;
             }
           END

           self.output = 'UB'

           explanation = <<-END
             <p>
               The code compiles perfectly (some compilers might give warnings though)
               but its behaviour is undefined: the parameter <code>x</code>
               is a local variable (meaning it's located on the satck)
               and returning a reference to it is a bad idea since
               <code>x</code> gets popped off the stack and hence
               its address refers to no man's land.
             </p>
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             #{show_explanation(explanation)}
           END
         end
      %>

      <%=
        exercise do
          extend GitMixin

          <<-END
            #{git_link 'swap/swap.sln'}
            <p>
              Write the function <code>swap</code> that can swap the values
              of two <code>int</code> variables using the following syntax: <code>swap(x, y)</code>.
            </p>
          END
        end
      %>

      <%=
        exercise do
          extend GitMixin
          extend SourceCodeMixin

          self.source = <<-END
            std::vector<int> ns = { 1, 10, 1 };

            max(ns)++;

            // ns must now contain { 1, 11, 1 }
          END

          <<-END
            #{git_link 'max/max.sln'}
            <p>
              Write the function <code>max</code> that, given a <code>std::vector&lt;int&gt;</code>,
              returns a reference to the maximum element. If more than one maximum exists,
              the a reference to the leftmost once (i.e. lowest index) should be returned.
              <code>max</code>'s behaviour is undefined for empty vectors, i.e.
              you don't have to take this corner case into account.
            </p>
            <p>
             The following code should work:
            </p>                      
            #{show_source_editor}
          END
        end
      %>

    </div>
  </body>

  <script>
    Quiz.formatQuizzes();
    SourceEditor.initialize();
    Revealer.initialize();
  </script>
</html>
