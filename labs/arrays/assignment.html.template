<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>PVM Assignment</title>
    <%= default_externals %>
    <script src="<%= Settings::SHARED_URL %>/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="<%= Settings::SHARED_URL %>/source-editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="<%= Settings::SHARED_URL %>/revealer.js" type="text/javascript" charset="utf-8"></script>

    <%= Html::Generation::Quiz.setup %>
    <style>
      #colours {
        margin-left: auto;
        margin-right: auto;
        width: 50%;
      }

      #colours td:first-child {
        color: #FFF;
        text-align: center;
      }

      #colours td {
        padding: 5px;
      }

      input {
        width: 100px;
      }

      input.correct {
        background: #AFA;
      }

      input.incorrect {
        background: #FAA
      }

      .revealer {
        border: 1px solid black;
        padding: 10px;
        width: 25%;
        margin: 20px auto;
        text-align: center;
        cursor: help;
        box-shadow: 10px 10px 5px #AAA;
      }

      .explanation {
        border: 1px solid black;
        box-shadow: 5px 5px 5px #AAA;
        padding: 10px;
        width: 90%;
        margin: 10px auto;
      }

      .message {
        font-size: 2em;
        font-weight: bold;
        text-align: center;
        width: 75%;
        margin: 100px auto;
        padding: 20px;
        background: #F44;
        box-shadow: 0px 0px 50px 30px #F44;
      }

      .git {
        border: 1px solid black;
        padding: 10px;
        width: 80%;
        margin: 10px auto;
        text-align: center;
        font-weight: bold;
      }
    </style>
  </head>

  <body>
    <header>
      <div class="center-vertically">Arrays</div>
    </header>
    <div id="contents">
      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             int main()
             {
               int* ns = create_range(1, 5);

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             void process(int* ns, int size)
             {
               for ( int i = 0; i != size; ++i )
               {
                 ns[i] *= 2;
               }
             }

             int main()
             {
               int* ns = create_range(1, 5);

               process(ns, 5);

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 It is important to note that the <code>process</code> function receives
                 a pointer to the array. Therefore, any modifications it makes
                 to the array are felt by <code>main</code>.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int main()
             {
               int* ns = new int[5];

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           self.output = '???'

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 The contents of a freshly allocated array are unknown.
                 Memory is not "cleared" or reset to 0 for you behind the scenes.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             int main()
             {
               int* ns = create_range(1, 5);

               ns[3] = 0;

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             int main()
             {
               int* ns = create_range(1, 5);
               int* p = &ns[2];

               *p = 0;

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 <code>p</code> contains the address of the element
                 with index 2. Writing to <code>p</code> has the same
                 effect as writing to <code>ns[2]</code>.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             int main()
             {
               int* ns = create_range(1, 5);
               int* p = &ns[1];

               p[0] = 0;

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 <code>p[0]</code> means "take the first element
                 of the array starting at address <code>p</code>".
                 Even though we never actually created an array at that address,
                 we can pretend we did.
                 Since <code>p</code> points to <code>ns[1]</code>,
                 the array pointed at by <code>p</code> starts there too, meaning
                 <code>p[0]</code> and <code>ns[1]</code> are the same.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             int main()
             {
               int* ns = create_range(1, 5);
               int* p = &ns[2];

               p[1] = 0;

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 <code>p</code> can be seen as an array overlapping
                 with <code>ns</code>: it's shifted three items
                 to the right with respect to <code>ns</code>.
                 <code>p[0]</code> coincides with <code>ns[2]</code>, and similarly,
                 <code>p[1]</code> with <code>ns[3]</code>.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             int main()
             {
               int* ns = create_range(1, 5);
               int* p = &ns[2];

               p[-2] = 0;

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 There's nothing wrong with negative indices as long
                 as you end up inside the array.
               </p>
             </div>
           END
         end
      %>

      <%=
         exercise(Lib::Interpretation) do
           self.source = <<-END
             #include <iostream>

             int* create_range(int a, int b)
             {
               int size = b - a + 1;
               int* result = new int[size];

               for ( int i = 0; i != size; ++i )
               {
                 result[i] = a + i;
               }

               return result;
             }

             int main()
             {
               int* ns = create_range(1, 5);
               int* p = &ns[1];

               p[-2] = 0;

               for ( int i = 0; i != 5; ++i )
                 std::cout << ns[i];

               delete[] ns;
             }
           END

           self.output = '???'

           <<-END
             <p>What is the output of the following code?</p>
             #{show_source_editor}
             #{if input then show_input else '' end}
             #{show_output_field}
             <div data-revealer="Show explanation" class="explanation">
               <p>
                 You're not allowed to go beyond the array's bounds.
               </p>
             </div>
           END
         end
      %>
              
      <%=
        exercise do
          extend SolutionMixin
          extend GitMixin

          <<-END
            #{git_link 'minmax/minmax.sln'}
            <p>
              A Visual Studio solution is available at the location shown above.
              Look for <code>TODO</code> tags to find out where you need to write code.
            </p>
            <p>
              Write three overloads of a <code>minmax</code>:
            </p>
            <ul>
              <li>
                <code>void minmax(const int* ns, int size, int* min, int* max);</code>
              </li>
              <li>
                <code>void minmax(const std::vector&lt;int&gt;* ns, int* min, int* max);</code>
              </li>
              <li>
                <code>template&lt;unsigned N&gt; void minmax(const std::array&lt;int, N&gt;* ns, int* min, int* max);</code>
              </li>
            </ul>
            <p>
              These functions must each, given a sequence of integers,
              return both the minimum and maximum using out-parameters.
              Try to make each overload share as much code as possible (i.e. minimise copy pasting).
            </p>
          END
        end
      %>

      <%=
        exercise do
          extend SolutionMixin
          extend GitMixin

          <<-END
            #{git_link 'most-frequent/most-frequent.sln'}
            <p>
              Write the function <code>int most_frequent(std::vector&lt;int&gt;* ns)</code> that
              returns the element of <code>ns</code> that appears the most often. For example,
              given a sequence <code>1 2 2 3 3 3</code>, <code>3</code> appears most often.
              If <code>ns</code> is empty, the function should return <code>-1</code>.
            </p>
          END
        end
      %>

      <%=
        exercise do
          extend SolutionMixin
          extend GitMixin

          <<-END
            #{git_link 'most-frequent/longest-increasing-subsequence.sln'}
            <p>
              Write the function <code>bool longest_increasing_subsequence(const std::vector&lt;int&gt;* ns, int* start_index, int* end_index)</code>
              that looks for the longest increasing subsequence. A few examples:
            </p>
            <ul>
              <li><span style="font-weight: bold;">0 1 2 3 4</span> 0 1</li>
              <li>0 1 <span style="font-weight: bold;">0 1 2 3 4</span></li>
              <li>0 1 2 <span style="font-weight: bold;">0 1 2 3</span> 0 1</li>
              <li>0 10 100 <span style="font-weight: bold;">0 1 50 3000 30001</span> 0 -1</li>
            </ul>
            <p>
              If there are multiple longest subsequences, the one appearing first should be returned.
            </p>
             <p>
               Equal values are also considered increasing: <code>5 5 5 5</code> is an increasing sequence of length 4,
               <code>1 2 2 3 3 3</code> is an increasing sequence of length 6.
             </p>
            <p>
              The function <code>longest_increasing_subsequence</code> should return the start and end of this longest increasing subsequence
              using out-parameters. Examples:
            </p>
            <ul>
              <li><span style="font-weight: bold;">0 0 0</span>: start_index = 0, end_index = 2</li>
              <li><span style="font-weight: bold;">0 1 2 3 4</span> 0 1: start_index = 0, end_index = 4</li>
              <li>0 1 <span style="font-weight: bold;">0 1 2 3 4</span>: start_index = 2, end_index = 6</li>
            </ul>
            <p>
              The function also returns a <code>bool</code>: it must return <code>true</code> whenever <code>ns</code> is nonempty,
              and <code>false</code> when <code>ns</code> is empty. In the latter case, <code>start_index</code> and
              <code>end_index</code> can contain arbitrary values, as there is no longest increasing subsequence to speak of.
            </p>
          END
        end
      %>

      <%=
        exercise do
          extend SolutionMixin
          extend GitMixin

          <<-END
            #{git_link 'lone-wolf/lone-wolf.sln'}
            <p>
              Write the function <code>void lone_wolf(const std::vector&lt;unsigned&gt;* ns)</code> that, given a list of <code>unsigned int</code>s
              (i.e. <code>int</code>s without sign bit, you can treat them the same as signed <code>int</code>s), looks for the "lone wolf":
              the list <code>ns</code> contains pairs of integers plus one unpaired integer, which we call the lone wolf. For example,
            </p>
            <ul>
              <li>0 0 1 1 2 2 3: the lone wolf is 3.</li>
              <li>0 1 2 1 0: the lone wolf is 2.</li>
              <li>5: the lone wolf is 5.</li>
              <li>5 5 5: the lone wolf is 5.</li>
            </ul>
            <p>
              Your function is allowed to assume that the list does indeed contain N pairs + one unpaired integer, i.e. it does
              not have to work correctly if given the list <code>1 2 3</code>. Feel free to use any data structure you want (e.g. <a href="http://www.cplusplus.com/reference/map/"><code>std::map</code></a>,
              <a href="http://www.cplusplus.com/reference/set/set/"><code>std::set</code></a>, &hellip;)
            </p>
            <p>
              Implement the function such that
            </p>
            <ul>
              <li>it is fast: each <code>n</code> of <code>ns</code> is only read once.</li>
              <li>it consumes little memory: no extra data structures are necessary.</li>
            </ul>
          END
        end
      %>

      <%=
        exercise do
          extend SolutionMixin
          extend GitMixin

          <<-END
            #{git_link 'bitsort/bitsort.sln'}
            <p>
              Write the function <code>void bitsort(std::vector&lt;unsigned&gt;* ns)</code> that, given a list that
              contains only <code>0</code>s and <code>1</code>s, sorts this list in place (i.e. the function modifies the list pointed to by <code>ns</code>).
              For example, the list 0 1 0 1 must be transformed into 0 0 1 1.
            </p>
            <p>
              Implement the function such that
            </p>
            <ul>
              <li>it is fast: it must work in linear time.</li>
              <li>memory is accessed sequentially (better cache performance): you can only read the <code>i+1</code>th element after reading the <code>i</code>th, and analogously for writes.</li>
            </ul>
          END
        end
      %>

    </div>
  </body>

  <script>
    Quiz.formatQuizzes();
    SourceEditor.initialize();
    Revealer.initialize();
  </script>
</html>
